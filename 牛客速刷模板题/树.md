# 树
## 前/中/后序遍历
## 层次遍历
利用队列来实现层次遍历，访问一个节点时就从堆中抛出，然后加入左右子结点
- [层次遍历判断是满足完全二叉树](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=2299105&ru=%2Fpractice%2Fa69242b39baf45dea217815c7dedb52b&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
~~~java
    public boolean isCompleteTree (TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        boolean ifVisitedNull = false;
        while(!queue.isEmpty()){
            if(queue.peek() == null) {
                ifVisitedNull = true;
                queue.poll();
                continue;
            }
            if(ifVisitedNull) return false;
            queue.add(queue.peek().left);
            queue.add(queue.poll().right);
        }

        return true;
    }
~~~
## 二叉搜索树
一个重要特性就是中序遍历是一个升序数组
## 深度和宽度优先算法
- 递归计算最大深度
~~~java
public int maxDepth (TreeNode root) {
    if(root == null) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
~~~
- 深度遍历合并两个树
~~~java
    public TreeNode mergeTrees (TreeNode t1, TreeNode t2) {
        if(t1 == null && t2 == null) return null;
        if(t1 == null || t2 == null) return t1 == null? t2: t1;

        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    }
~~~